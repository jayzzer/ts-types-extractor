import { program } from 'commander';
import consola from 'consola';
import fs from 'fs';
import path from 'path';
import prompts from 'prompts';
import { SetRequired } from 'type-fest';
import ts from 'typescript';
import { extractEnumEntries } from './helpers';

const DEFAULT_TARGET = ts.ScriptTarget.ES2020;
const DEFAULT_OUTPUT = './types.d.ts';
const TARGET_ENTRIES = extractEnumEntries(ts.ScriptTarget);

program
  .name('ts-types')
  .description('CLI for generating TypeScript .d.ts file based on node_modules')
  .option(
    '-t, --target <version>',
    'target EcmaScript version',
    (value) => ts.ScriptTarget[value as keyof typeof ts.ScriptTarget]
  )
  .option('-o, --output <path>', 'output file path')
  .option(
    '--ob, --objects <objects...>',
    'list of objects names to be included'
  )
  .option('-c, --config <path>', 'config file path')
  .option('-v, --verbose', 'show verbose logs')
  .parse();

export interface Config {
  /** Target EcmaScript version. */
  target?: ts.ScriptTarget;
  /**
   * Output file name with generated types.
   *
   * @default ./types.d.ts
   */
  output?: string;
  /**
   * List of objects names to be included.
   *
   * @example ['Object', 'Function', 'Array']
   **/
  objects?: string[];
  verbose?: boolean;
}

type ResultConfig = SetRequired<Config, 'target' | 'objects' | 'output'>;

const options = program.opts<Config>();
(async () => {
  const results = await prompts([
    {
      type: () => (!options.target ? 'select' : null),
      name: 'target',
      message: 'Select EcmaScript target version',
      choices: TARGET_ENTRIES.map(([k, v]) => ({ title: k, value: v })),
      initial: DEFAULT_TARGET,
    },
    {
      type: () => (!options.objects ? 'list' : null),
      name: 'objects',
      message: 'Enter objects names to be included',
      initial: '',
    },
    {
      type: () => (!options.output ? 'text' : null),
      name: 'output',
      message: 'Enter path to output directory',
      initial: DEFAULT_OUTPUT,
    },
  ]);

  const resultOptions: ResultConfig = {
    target: options.target ?? results.target,
    objects: [...(options.objects ?? results.objects), 'IArguments'],
    output: options.output ?? results.output,
  };

  consola.start('Generating types...');
  generateTypes(resultOptions);
  consola.success(`Generated types to "${resultOptions.output}"`);
})();

async function generateTypes({ target, output, objects }: ResultConfig) {
  const tsLibPath = path.dirname(require.resolve('typescript'));
  consola.info(`Found typescript lib path: ${tsLibPath}`);
  const outputFilePath = output;
  fs.writeFileSync(
    outputFilePath,
    '/* This is autogenerated file. Do not edit! */\n/* eslint-disable */\n'
  );

  const libFiles = fs.readdirSync(tsLibPath);
  const libFilesToRead = libFiles.filter((file) => {
    if (!file.startsWith('lib.')) return false;

    const [, maybeEsVersion] = file.split('.');
    if (!maybeEsVersion.includes('es')) return false;

    const fileEsVersion = (
      maybeEsVersion === 'esnext' ? 'ESNext' : maybeEsVersion.toUpperCase()
    ) as keyof typeof ts.ScriptTarget;
    const fileScriptTargetVersion = ts.ScriptTarget[fileEsVersion];
    if (fileScriptTargetVersion > target) return false;

    return true;
  });

  const scanner = ts.createScanner(target, false, ts.LanguageVariant.Standard);
  for (const libFile of libFilesToRead) {
    const fileText = fs.readFileSync(path.join(tsLibPath, libFile), {
      encoding: 'utf-8',
    });
    scanner.setText(fileText);

    while (scanner.scan() !== ts.SyntaxKind.EndOfFileToken) {
      const currentToken = scanner.getToken();

      switch (currentToken) {
        case ts.SyntaxKind.InterfaceKeyword: {
          let interfacePayload = scanner.getTokenText();
          while (scanner.scan() !== ts.SyntaxKind.Identifier) {
            interfacePayload += scanner.getTokenText();
          }
          const interfaceName = scanner.getTokenText();
          if (!objects.find((needObject) => interfaceName.includes(needObject)))
            break;
          // save interface name
          interfacePayload += interfaceName;

          while (scanner.scan() !== ts.SyntaxKind.OpenBraceToken) {
            interfacePayload += scanner.getTokenText();
          }
          // save open brace
          interfacePayload += scanner.getTokenText();

          let bracesCount = 1;
          while (bracesCount) {
            const innerCurrentToken = scanner.scan();
            interfacePayload += scanner.getTokenText();

            switch (innerCurrentToken) {
              case ts.SyntaxKind.OpenBraceToken:
                bracesCount += 1;
                break;
              case ts.SyntaxKind.CloseBraceToken:
                bracesCount -= 1;
            }
          }

          fs.appendFileSync(outputFilePath, `${interfacePayload}\n`);
          break;
        }
        case ts.SyntaxKind.DeclareKeyword: {
          let declarePayload = scanner.getTokenText();
          while (scanner.scan() !== ts.SyntaxKind.Identifier) {
            declarePayload += scanner.getTokenText();
          }
          const typeName = scanner.getTokenText();

          if (!objects.find((needObject) => typeName.includes(needObject)))
            break;
          declarePayload += scanner.getTokenText();

          while (
            ![
              ts.SyntaxKind.OpenBraceToken,
              ts.SyntaxKind.SemicolonToken,
            ].includes(scanner.scan())
          ) {
            declarePayload += scanner.getTokenText();
          }
          // save open brace or semicolon
          declarePayload += scanner.getTokenText();

          if (scanner.getToken() === ts.SyntaxKind.OpenBraceToken) {
            let bracesCount = 1;
            while (bracesCount) {
              const innerCurrentToken = scanner.scan();
              declarePayload += scanner.getTokenText();

              switch (innerCurrentToken) {
                case ts.SyntaxKind.OpenBraceToken:
                  bracesCount += 1;
                  break;
                case ts.SyntaxKind.CloseBraceToken:
                  bracesCount -= 1;
              }
            }
          }

          fs.appendFileSync(outputFilePath, `${declarePayload}\n`);
          break;
        }
      }
    }
  }
}
