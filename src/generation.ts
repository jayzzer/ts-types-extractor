import consola from 'consola';
import fs from 'fs';
import path from 'path';
import ts from 'typescript';
import { ResultConfig } from './config';

const TOP_INFO = '/* This is autogenerated file. Do not edit! */\n/* eslint-disable */\n';

export async function generateTypes({ target, output, objects }: ResultConfig) {
  const tsLibPath = path.dirname(require.resolve('typescript'));
  consola.info(`Found TypeScript lib path: ${tsLibPath}`);

  const outputFilePath = output;
  consola.verbose(`Creating output file: ${outputFilePath}`);
  fs.writeFileSync(outputFilePath, TOP_INFO);
  consola.verbose(`Created output file: ${outputFilePath}`);

  consola.verbose(`Finding TypeScript lib files to read...`);
  const libFiles = fs.readdirSync(tsLibPath);
  const libFilesToRead = libFiles.filter((file) => {
    if (!file.startsWith('lib.')) return false;

    const [, maybeEsVersion] = file.split('.');
    if (!maybeEsVersion.includes('es')) return false;

    const fileEsVersion = (
      maybeEsVersion === 'esnext' ? 'ESNext' : maybeEsVersion.toUpperCase()
    ) as keyof typeof ts.ScriptTarget;
    const fileScriptTargetVersion = ts.ScriptTarget[fileEsVersion];
    if (fileScriptTargetVersion > target) return false;

    return true;
  });
  consola.verbose(`Picked TypeScript lib files to read: ${libFilesToRead.join(', ')}`);

  consola.verbose(`Starting extracting types...`);
  const scanner = ts.createScanner(target, false, ts.LanguageVariant.Standard);
  for (const libFile of libFilesToRead) {
    consola.verbose(`Extracting types from ${libFile}...`);
    const fileText = fs.readFileSync(path.join(tsLibPath, libFile), {
      encoding: 'utf-8',
    });
    scanner.setText(fileText);

    while (scanner.scan() !== ts.SyntaxKind.EndOfFileToken) {
      const currentToken = scanner.getToken();

      switch (currentToken) {
        case ts.SyntaxKind.InterfaceKeyword: {
          let interfacePayload = scanner.getTokenText();
          while (scanner.scan() !== ts.SyntaxKind.Identifier) {
            interfacePayload += scanner.getTokenText();
          }
          const interfaceName = scanner.getTokenText();
          if (!objects.find((needObject) => interfaceName.includes(needObject))) break;
          consola.verbose(`Found interface ${interfaceName} in ${libFile}`);

          // save interface name
          interfacePayload += interfaceName;

          while (scanner.scan() !== ts.SyntaxKind.OpenBraceToken) {
            interfacePayload += scanner.getTokenText();
          }
          // save open brace
          interfacePayload += scanner.getTokenText();

          let bracesCount = 1;
          while (bracesCount) {
            const innerCurrentToken = scanner.scan();
            interfacePayload += scanner.getTokenText();

            switch (innerCurrentToken) {
              case ts.SyntaxKind.OpenBraceToken:
                bracesCount += 1;
                break;
              case ts.SyntaxKind.CloseBraceToken:
                bracesCount -= 1;
            }
          }

          fs.appendFileSync(outputFilePath, `${interfacePayload}\n`);
          consola.verbose(`Extracted interface ${interfaceName}`);
          break;
        }
        case ts.SyntaxKind.DeclareKeyword: {
          let declarePayload = scanner.getTokenText();
          while (scanner.scan() !== ts.SyntaxKind.Identifier) {
            declarePayload += scanner.getTokenText();
          }
          const typeName = scanner.getTokenText();

          if (!objects.find((needObject) => typeName.includes(needObject))) break;
          consola.verbose(`Found type ${typeName} in ${libFile}`);

          declarePayload += scanner.getTokenText();

          while (
            ![ts.SyntaxKind.OpenBraceToken, ts.SyntaxKind.SemicolonToken].includes(scanner.scan())
          ) {
            declarePayload += scanner.getTokenText();
          }
          // save open brace or semicolon
          declarePayload += scanner.getTokenText();

          if (scanner.getToken() === ts.SyntaxKind.OpenBraceToken) {
            let bracesCount = 1;
            while (bracesCount) {
              const innerCurrentToken = scanner.scan();
              declarePayload += scanner.getTokenText();

              switch (innerCurrentToken) {
                case ts.SyntaxKind.OpenBraceToken:
                  bracesCount += 1;
                  break;
                case ts.SyntaxKind.CloseBraceToken:
                  bracesCount -= 1;
              }
            }
          }

          fs.appendFileSync(outputFilePath, `${declarePayload}\n`);
          consola.verbose(`Extracted type ${typeName}`);
          break;
        }
      }
    }
  }
}
